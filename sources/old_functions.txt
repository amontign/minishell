# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    old_functions.txt                                  :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: cbernaze <cbernaze@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/06/19 17:03:56 by cbernaze          #+#    #+#              #
#    Updated: 2023/07/26 13:50:24 by cbernaze         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

// int	is_quotes(char *cmd_line, int *i)
// {
// 	if (cmd_line[*i] == 34)
// 	{
// 		*i += 1;
// 		while (cmd_line[*i] != 34 && cmd_line[*i] != '\0')
// 			*i += 1;
// 		if (cmd_line[*i] == 34)
// 			*i += 1;
// 		return (1);
// 	}
// 	if (cmd_line[*i] == 39)
// 	{
// 		*i += 1;
// 		while (cmd_line[*i] != 39 && cmd_line[*i] != '\0')
// 			*i += 1;
// 		if (cmd_line[*i] == 39)
// 			*i += 1;
// 		return (1);
// 	}
// 	return (0);
// }




// int	btwn_double(char *cmd_line, int spec_pos, int *i)
// {
// 	int	j;
// 	int	open_quote;
// 	int	close_quote;

// 	j = 0;
// 	open_quote = -1;
// 	close_quote = -1;
// 	while (cmd_line[j] != '\0')
// 	{
// 		if (cmd_line[j] == quote)
// 		{
// 			open_quote = j;
// 			j++;
// 			while (cmd_line[j] != quote && cmd_line[j] != '\0')
// 				j++;
// 			if (cmd_line[j] == quote && close_quote < 0)
// 			{
// 				close_quote = j;
// 				if (spec_pos > open_quote && spec_pos < close_quote)
// 				{
// 					while (cmd_line[*i] != quote && cmd_line[*i])
// 						*i += 1;
// 					if (cmd_line[*i] == quote)
// 						*i += 1;
// 					return (TRUE);
// 				}
// 				else
// 				{
// 					open_quote = -2;
// 					close_quote = -2;
// 				}
// 			}
// 			else
// 				return (FALSE);
				//renvoyer un message d'erreur plus tard lors du parsing
// 		}
// 		j++;
// 	}
// 	return (FALSE);
// }




// int	what_meta(char *cmd_line, char c, char c_plus_one, int *i)
// {
// 	if ((c == '<'  && c_plus_one != '<') || (c == '>'  && c_plus_one != '>'))
// 	{
// 		*i += 1;
// 		if (btwn_quotes(cmd_line, (*i) - 1, i, 39) == FALSE
// 			&& btwn_quotes(cmd_line, (*i) - 1, i, 34) == FALSE)
// 		{
// 			while (cmd_line[*i] == ' ')
// 				*i += 1;
// 			while (is_meta(cmd_line[*i], cmd_line[*i + 1]) == FALSE
// 					&& cmd_line[*i] != '\0' && cmd_line[*i] != ' ')
// 				*i += 1;
// 			return (1);
// 		}
// 	}
// 	if ((c == '<' && c_plus_one == '<')
// 			|| (c == '>' && c_plus_one == '>'))
// 	{
// 		*i += 2;
// 		if (btwn_quotes(cmd_line, (*i) - 1, i, 39) == FALSE
// 				&& btwn_quotes(cmd_line, (*i) - 1, i, 34) == FALSE)
// 		{
// 			while (cmd_line[*i] == ' ')
// 				*i += 1;
// 			while (is_meta(cmd_line[*i], cmd_line[*i + 1]) == FALSE
// 					&& cmd_line[*i] != '\0' && cmd_line[*i] != ' ')
// 				*i += 1;
// 			return (1);
// 		}	}
// 	return (0);
// }




/*Compte le nombre tokens dans une ligne de commandes*/

// int	cmd_count(char *line)
// {
// 	int	i;
// 	int	count;

// 	i = 0;
// 	count = 0;
// 	while (line[i])
// 	{
// 		if (is_meta(line, line[i], line[i + 1], i) != FALSE)
// 		{
// 			count += is_redir(line, line[i], line[i + 1], &i);
// 			count += is_pipe(line[i], &i);
// 		}
// 		// while (line[i] == ' ')
// 		// 	i++;
// 		if (is_meta(line, line[i], line[i + 1], i) == FALSE && line[i])
// 		{
// 			count++;
// 			while (is_meta(line, line[i], line[i + 1], i) != PIPE && line[i])
// 			{
// 				if (is_meta(line, line[i], line[i + 1], i) == REDIR)
// 					count += is_redir(line, line[i], line[i + 1], &i);
// 				else
// 					i++;
// 			}
// 		}
// 	}
// 	return (count);
// }




// void	which_token_type(t_parsing **lexing)
// {
	// t_parsing	*temp;
//
	// temp = *lexing;
	// while (temp)
	// {
		// if (temp->cmd[0] == '|')
			// temp->token_type = TOKEN_PIPE;
		// if (temp->cmd[0] == '<' || temp->cmd[0] == '>')
			// temp->token_type = TOKEN_REDIR;
		// else
			// temp->token_type = TOKEN_CMD;
		// temp = temp->next;
	// }
// }
//

// /* Dans le cas ou on a un pipe, j'avance de un dans ma string
// et j'incremente mon comtpeur de token.*/

// int	is_pipe(char c, int *i)
// {
// 	if (c == '|')
// 	{
// 		*i += 1;
// 		return (1);
// 	}
// 	return (0);
// }

// /*Les deux fonctions ci-dessous permettent de voir si un pipe
// ou une redir se situe ou non entre des quotes*/

// int	btwn_quotes(char *cmd_line, int meta_pos, char quote)
// {
// 	t_honte	honte;
// 	int		j;

// 	j = 0;
// 	honte = init_honte(cmd_line, meta_pos, quote);
// 	while (cmd_line[j] != '\0')
// 	{
// 		if (cmd_line[j] == quote)
// 		{
// 			honte.open_quote = j;
// 			j++;
// 			while (cmd_line[j] != quote && cmd_line[j] != '\0')
// 				j++;
// 			if (btwn_quotes_2(&honte, j) == TRUE)
// 				return (TRUE);
// 		}
// 		j++;
// 	}
// 	return (FALSE);
// }

// int	btwn_quotes_2(t_honte *honte, int j)
// {
// 	if (honte->cmd_line[j] == honte->quote && honte->close_quote < 0)
// 	{
// 		honte->close_quote = j;
// 		if (honte->meta_pos > honte->open_quote
// 			&& honte->meta_pos < honte->close_quote)
// 			return (TRUE);
// 		else
// 		{
// 			honte->open_quote = -2;
// 			honte->close_quote = -2;
// 		}
// 	}
// 	return (FALSE);
// }


// int	untreated_meta(char *cmd_line, int i)
// {
// 	if (ft_strcmp_minishell(cmd_line + i, "<<<") == TRUE)
// 	{
// 		(ft_printf("minishell: <<<: command not treated by minishell\n"));
// 		return (ERROR);
// 	}
// 	if (ft_strcmp_minishell(cmd_line + i, ">>>") == TRUE)
// 	{
// 		(ft_printf("minishell: >>>: command not treated by minishell\n"));
// 		return (ERROR);
// 	}
// 	if (ft_strcmp_minishell(cmd_line + i, "||") == TRUE)
// 	{
// 		(ft_printf("minishell: ||: command not treated by minishell\n"));
// 		return (ERROR);
// 	}
// 	return (0);
// }

// int	are_quotes_closed(char *cmd_line, int quote, int other_quote)
// {
// 	t_quote	data;
// 	int		i;

// 	i = 0;
// 	data.count_quotes = 0;
// 	data.quote = quote;
// 	data.other_quote = other_quote;
// 	while (cmd_line[i])
// 	{
// 		if (cmd_line[i] == quote)
// 			are_quotes_closed_2(&data, cmd_line, &i);
// 		i++;
// 	}
// 	if ((data.count_quotes % 2) != 0)
// 	{
// 		ft_printf("minishell: %c: quotes not closed\n", (char)quote);
// 		return (ERROR);
// 	}
// 	return (0);
// }

// void	are_quotes_closed_2(t_quote *data, char *cmd_line, int *i)
// {
// 	if (btwn_quotes(cmd_line, *i, data->other_quote) == FALSE)
// 	{
// 		*i += 1;
// 		data->count_quotes++;
// 		while (cmd_line[*i] != data->quote && cmd_line[*i])
// 			*i += 1;
// 		if (cmd_line[*i] == data->quote)
// 			data->count_quotes++;
// 	}
// }



//
// void	is_substitute_dollar(t_parsing **tmp, int dollar_pos)
// {
	// t_parsing	*new;
	// char		*dollar;
	// int			i;
	// int			j;
	// int			size_dollar;
//
	// i = dollar_pos + 1;
	// size_dollar = 1;
	// while (ft_isalnum((int)((*tmp)->cmd[i])) == TRUE)
	// {
		// size_dollar++;
		// i++;
	// }
	// dollar = malloc((size_dollar + 1) * sizeof(char));
	// if (!dollar)
	// {
		// ft_lstclear_minishell(tmp);
		// return ;
	// }
	// i = dollar_pos + 1;
	// j = 0;
	// dollar[j] = '$';
	// j++;
	// while (ft_isalnum((int)((*tmp)->cmd[i])) == TRUE)
	// {
		// dollar[j] = (*tmp)->cmd[i];
		// i++;
		// j++;
	// }
	// dollar[j] = '\0';
	// new = ft_lstnew_minishell(dollar, size_dollar, TO_SUBSTITUTE);
	// new->next = (*tmp)->next;
	// new->previous = (*tmp);
	// (*tmp)->next = new;
// }


// void	free_quotes(t_parsing **lexing)
// {
// 	int	i;

// 	i = 0;
// 	if ((*lexing)->token_type == TOKEN_CMD && (*lexing)->remove_quote)
// 	{
// 		while (i < ft_strlen_plus((*lexing)->cmd_split))
// 		{
// 			free((*lexing)->remove_quote[i]);
// 			i++;
// 		}
// 	}
// 	if ((*lexing)->token_type == REDIR && (*lexing)->remove_quote)
// 	{
// 		free((*lexing)->remove_quote[0]);
// 	}
// 	free((*lexing)->remove_quote);
// }


/*Echange la position de deux maillons d'une liste de type t_parsing*/

void	swap_nodes(t_parsing **lexing)
{
	t_parsing	*tmp;
	t_parsing	*node_to_move;

	tmp = *lexing;
	node_to_move = tmp->next;
	tmp->next = node_to_move->next;
	tmp->previous = node_to_move;
	if (node_to_move->next)
		node_to_move->next->previous = tmp;
	node_to_move->previous = NULL;
	node_to_move->next = tmp;
	*lexing = node_to_move;
	set_index(lexing);
	ft_lstclear_minishell(&node_to_move);
}

// int	untreat_redir(char *cmd_line, int *i)
// {
// 	if (cmd_line[*i] == '>' && cmd_line[*i + 1] == '>'
// 		&& cmd_line[*i + 2] == '>')
// 		return (ft_printf("minishell: syntax error unexpected token near \
// '>>'\n"), ERROR_SYNTAX);
// 	if (cmd_line[*i] == '<' && cmd_line[*i + 1] == '<'
// 		&& cmd_line[*i + 2] == '<')
// 		return (ft_printf("minishell: syntax error unexpected token near \
// '<<'\n"), ERROR_SYNTAX);
// 	if (cmd_line[*i] == '>' && cmd_line[*i + 1] == '>' && cmd_line[*i + 2] == '|')
// 		return (ft_printf("minishell: syntax error near \
// unexpected token `|'\n"), ERROR_SYNTAX);
// 	if (cmd_line[*i] == '>' && cmd_line[*i + 1] == '\0')
// 		return (ft_printf("minishell: syntax error near \
// unexpected token `newline'\n"), ERROR_SYNTAX);
// 	if (cmd_line[*i] == '<' && cmd_line[*i + 1] == '\0')
// 		return (ft_printf("minishell: syntax error near \
// unexpected token `newline'\n"), ERROR_SYNTAX);
// 	if (cmd_line[*i] == '<' && cmd_line[*i + 1] == '>' && cmd_line[*i + 2] == '\0')
// 		return (ft_printf("minishell: syntax error near \
// unexpected token `newline'\n"), ERROR_SYNTAX);
// 	if (cmd_line[*i] == '>' && cmd_line[*i + 1] == '<' && cmd_line[*i + 2] == '\0')
// 		return (ft_printf("minishell: syntax error near \
// unexpected token `<'\n"), ERROR_SYNTAX);
// 	return (0);
// }